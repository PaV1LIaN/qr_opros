Ниже — рабочая реализация метода половинного деления (бисекции) и оценка операций.

### Исправленная программа (PHP)

```php
<?php
declare(strict_types=1);

function func(float $x): float
{
    return $x * $x - 2.0; // f(x) = x^2 - 2
}

$a = 0.0;
$b = 2.0;
$eps = 0.0001;

$fa = func($a);
$fb = func($b);
if ($fa * $fb >= 0) {
    throw new RuntimeException("На [a,b] нет смены знака: метод бисекции неприменим.");
}

$iters = 0;
// Гарантируем |x_mid - x*| <= eps: достаточно довести (b-a)/2 <= eps
while ( ($b - $a) / 2.0 > $eps ) {
    $c = ($a + $b) / 2.0;
    $fc = func($c);

    if ($fa * $fc <= 0) {
        $b = $c;
        $fb = $fc;
    } else {
        $a = $c;
        $fa = $fc;
    }
    $iters++;
}

$x = ($a + $b) / 2.0;

echo "Корень уравнения приблизительно равен {$x}\n";
echo "Количество итераций: {$iters}\n";
```

### Что получится для ваших данных

* Исходные параметры: (f(x)=x^2-2), (a=0), (b=2), (\varepsilon=10^{-4}).
* Необходимое число итераций:
  (n = \lceil \log_2!\big((b-a)/\varepsilon\big) \rceil = \lceil \log_2(20000) \rceil = 15).
* Приближённый корень после 15 шагов: (x \approx 1{.}414215087890625) (погрешность (\approx 1.53 \times 10^{-6} < 10^{-4})).

### Оценка количества операций

Если считать «дорогими» именно вычисления функции:

* Вычислений (f(x)): 2 на старте ((f(a), f(b))) + 1 на каждый шаг → (2 + n = 17).
* Сравнения/умножения для проверки знака — порядка (n).
* Арифметика над числами с плавающей точкой (среднее, разности) — по ~2–3 операции на итерацию.

Итого ключевое: **15 итераций**, **17 вычислений функции**.
